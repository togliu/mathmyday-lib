<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractComplex.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">finnmath</a> &gt; <a href="index.source.html" class="el_package">io.github.ltennstedt.finnmath.number.complex</a> &gt; <span class="el_source">AbstractComplex.kt</span></div><h1>AbstractComplex.kt</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Lars Tennstedt
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.ltennstedt.finnmath.number.complex

import com.google.common.annotations.Beta
import com.google.common.base.MoreObjects
import org.apiguardian.api.API
import java.io.Serializable
import java.util.Objects

/**
 * Base class for complex numbers
 *
 * @param N type of [real] and [imaginary]
 * @param T type of this
 * @param Q type of the quotient
 * @param A type of the absolute value
 * @param P type of the polar form
 * @property real real part
 * @property imaginary imaginary part
 * @constructor Constructs a AbstractComplex
 * @author Lars Tennstedt
 * @since 0.0.1
 */
@API(status = API.Status.EXPERIMENTAL, since = &quot;0.0.1&quot;)
@Beta
<span class="nc" id="L41">public abstract class AbstractComplex&lt;N : Number, T : AbstractComplex&lt;N, T, Q, A, P&gt;, Q, A, P&gt;(</span>
<span class="nc" id="L42">    public val real: N,</span>
<span class="nc" id="L43">    public val imaginary: N</span>
<span class="nc" id="L44">) : Number(), Serializable {</span>
    /**
     * Indicates if this is a unit
     *
     * @since 0.0.1
     */
    public abstract val isUnit: Boolean

    /**
     * Returns the sum of this and the [summand]
     *
     * @since 0.0.1
     */
    public abstract fun add(summand: T): T

    /**
     * Returns the difference of this and the [subtrahend]
     *
     * @since 0.0.1
     */

    public abstract fun subtract(subtrahend: T): T

    /**
     * Returns the product of this and the [factor]
     *
     * @since 0.0.1
     */
    public abstract fun multiply(factor: T): T

    /**
     * Returns the quotient of this and the [divisor]
     *
     * @throws IllegalArgumentException if [divisor] is not a unit
     * @since 0.0.1
     */
    public abstract fun divide(divisor: T): Q

    /**
     * Returns the power of this raised by the [exponent]
     *
     * @since 0.0.1
     */
    public abstract fun pow(exponent: Int): Q

    /**
     * Returns the negated [T]
     *
     * @since 0.0.1
     */
    public abstract fun negate(): T

    /**
     * Returns the inverted [T]
     *
     *@throws IllegalStateException if this is not a unit
     * @since 0.0.1
     */
    public abstract fun invert(): Q

    /**
     * Returns the square of the absolute value
     *
     * @since 0.0.1
     */
    public abstract fun absPow2(): N

    /**
     * Returns the absolute value
     *
     * @since 0.0.1
     */
    public abstract fun abs(): A

    /**
     * Returns the conjugated [T]
     *
     * @since 0.0.1
     */
    public abstract fun conjugate(): T

    /**
     * Returns the argument
     *
     * @throws IllegalStateException if this is equal to 0 by comparing
     * @since 0.0.1
     */
    public abstract fun argument(): A

<span class="nc" id="L133">    override fun toByte(): Byte = real.toByte()</span>

<span class="nc" id="L135">    override fun toShort(): Short = real.toShort()</span>

<span class="nc" id="L137">    override fun toInt(): Int = real.toInt()</span>

<span class="nc" id="L139">    override fun toLong(): Long = real.toLong()</span>

<span class="nc" id="L141">    override fun toFloat(): Float = real.toFloat()</span>

<span class="nc" id="L143">    override fun toDouble(): Double = real.toDouble()</span>

<span class="nc" id="L145">    override fun toChar(): Char = real.toChar()</span>

    /**
     * Returns this as polar form
     *
     * @throws IllegalStateException if this is equal to 0 by comparing
     * @since 0.0.1
     */
    public abstract fun toPolarForm(): P

    /**
     * Returns if this is equal to [other] by comparing
     *
     * @since 0.0.1
     */
    public abstract fun equalsByComparing(other: T): Boolean

    /**
     * Returns if this is not equal to [other] by comparing
     *
     * @since 0.0.1
     */
<span class="nc bnc" id="L167" title="All 2 branches missed.">    public fun doesNotEqualByComparing(other: T): Boolean = !equalsByComparing(other)</span>

<span class="nc" id="L169">    public operator fun plus(summand: T): T = add(summand)</span>

<span class="nc" id="L171">    public operator fun minus(subtrahend: T): T = subtract(subtrahend)</span>

<span class="nc" id="L173">    public operator fun times(factor: T): T = multiply(factor)</span>

<span class="nc" id="L175">    public operator fun div(divisor: T): Q = divide(divisor)</span>

    @Suppress(&quot;UNCHECKED_CAST&quot;)
<span class="nc" id="L178">    public operator fun unaryPlus(): T = this as T</span>

<span class="nc" id="L180">    public operator fun unaryMinus(): T = negate()</span>

<span class="nc" id="L182">    public fun operator1(): N = real</span>

<span class="nc" id="L184">    public fun operator2(): N = imaginary</span>

<span class="nc" id="L186">    override fun hashCode(): Int = Objects.hash(real, imaginary)</span>

    override fun equals(other: Any?): Boolean {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (this === other) return true</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (other !is AbstractComplex&lt;*, *, *, *, *&gt;) return false</span>
<span class="nc bnc" id="L191" title="All 4 branches missed.">        return real == other.real &amp;&amp; imaginary == other.imaginary</span>
    }

    override fun toString(): String =
<span class="nc" id="L195">        MoreObjects.toStringHelper(this).add(&quot;real&quot;, real).add(&quot;imaginary&quot;, imaginary).toString()</span>

    public companion object {
        private const val serialVersionUID = 1L
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>